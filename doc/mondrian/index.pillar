!Mondrian

Mondrian is an engine for graph-based visualization. While its roots date back to 2005, there have been multiple incarnations since then, including the ones from Roassal. The current version is based on Bloc, the new graphical engine for Pharo. The current version makes extensive use of Bloc and its mechanisms. As a result it requires a very short implementation that is specific to visualizing graphs. It turns out that most of the things we need for graphs are actually generic concepts that can be used for all sorts of other graphical needs.

To get a more concrete idea of what Mondrian is about, let's consider some examples. 


!!A few examples

The first example shows a tree made of nodes and interconnecting edges that are organized as a radial tree. Except that there are also two red edges that do not affect the layout.

${example:GtMondrianBasicExamples>>#passiveEdges|expandedPreview}$

Another one shows a UML-like visualization of a class hierarchy.

${example:GtMondrianDomainExamples>>#umlClasses|expandedPreview}$

Each of these examples are similar in that they are constructed as transformations of some input data into pictures. Yet, the transformation is different: 
- One shows a tree with nodes represented as rectangles. Another one shows nodes represented as UML class elements. 
- One shows only simple nodes. Another one also shows nested nodes.
- Most drawn edges affect the visualization, except for two red ones that even if thicker they are passive ones.


!!A tutorial


!!!Nodes, edges and layouts

The most basic parts of a Mondrian view are:
# Nodes
# Edges
# Layout

Let's see how we create these. First the nodes.

${example:GtMondrianBasicExamples>>#twoNodes|expandedPreview}$

Given those nodes, we can build edges.

${example:GtMondrianBasicExamples>>#oneEdgeBetweenTwoNodes|expandedPreview}$

And finally, we lay them out.

${example:GtMondrianBasicExamples>>#layoutOnOneEdgeBetweenTwoNodes|expandedPreview}$


!!!Shapes

The look and feel of nodes and edges is specified by Shapes, which can be included in the construction of nodes and edges.

A shape can be defined by a block that takes the node's model object as its argument and returns an instance of a Bloc element. In the example below, we see nine nodes drawn as circles with black borders, whose sizes depend on the number which each node represents.

${example:GtMondrianBasicExamples>>#nodesWithEllipses|expandedPreview}$

We can define the shape of edges in a similar way. In the example below, the nodes are connected by blue edges whose width varies depending on the node it tries to connect.

${example:GtMondrianBasicExamples>>#edgesWithThickerLines|expandedPreview}$


!!!Nesting

Mondrian graphs can also be nested. In other words, a node can have a subgraph.

${example:GtMondrianBasicExamples>>#nestedNodes|expandedPreview}$

Nested nodes behave like leaf nodes in that they can be connected through edges and laid out accordingly.

${example:GtMondrianBasicExamples>>#nestedWithEdges|expandedPreview}$


!!Differences to previous incarnations of Mondrian

The API has changed in comparison with the Roassal version because of the constraints and opportunities offered by Bloc:
- Nodes are defined through ==view nodes with: { ... }==, instead of ==view nodes: { ... }==. One reason is to make the definition more similar to the one of edges.
- Shapes are defined within the scope of a ==view nodes== or ==view edges== definition.
- Shapes are mainly defined explicitly by instantiating of ==BlElement== and its subclasses.
- The ==forEach:== clause can be cascaded after ==view nodes with: {...}==. This allows us to have multiple ==forEach:== statements per one nodes definition.
- The new ==forEach:in:== allows the user to define the id of the container for the children. In this way, we can define children in different parts of the parent node.


!!Domain-specific examples

Mondrian is useful for creating custom views that are specific to a given domain.


!!!Package dependencies

In this example, we see a list of packages arranged in a circle, with nested classes and the inheritance dependencies between the classes grouped at package level. One interesting thing is that the label of the packages shrinks to the available space offered by the size of the boxes. Another particularity is the use of parabolla arcs and heads.

${example:GtMondrianDomainExamples>>#packageDependencies|expandedPreview}$


!!!Examples dependencies

This examples shows a tree of dependencies between example methods. We can see here that the visualization can embed arbitrary elements, such as an editor element with syntax highlighting.

${example:GtMondrianDomainExamples>>#exampleDependencies|expandedPreview}$


!!The inner structure of an element editor

Visualization can be applied to any object or set objects. For example, the following visualization helps us understand how the editor element is composed out of smaller elements by showing the tree of the elements, each depicted with a label and a picture of the actual element.

${example:GtMondrianDomainExamples>>#editorElements|expandedPreview}$
