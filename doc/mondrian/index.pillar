!Mondrian

Mondrian is an engine for graph-based visualization. While its roots date back to 2005, there have been multiple incarnations since then, including the ones from Roassal. The current version is based on Bloc, the new graphical engine for Pharo. The current version makes extensive use of Bloc and its mechanisms. As a result it requires a very short implementation that is specific to visualizing graphs. It turns out that most of the things we need for graphs are actually generic concepts that can be used for all sorts of other graphical needs.

But enough talk. To get an idea of what Mondrian is about, let's consider some examples. 

!!A few examples

The first example shows a tree made of nodes and interconnecting edges that are organized as a radial tree. Except that there are also two red edges that do not affect the layout.

[[[example=GtMondrianBasicExamples>>#passiveEdges|expanded=true|noCode=true|show=gtLiveIn:]]]

Another one shows a UML-like visualization of a class hierarchy.

[[[example=GtMondrianDomainExamples>>#umlClasses|expanded=true|noCode=true|show=gtLiveIn:]]]

Each of these examples are similar in that they are constructed as transformations of some input data into pictures. Yet, the transformation is different: 
- One shows a tree with nodes represented as rectangles. Another one shows nodes represented as UML class elements. 
- One shows only simple nodes. Another one also shows nested nodes.
- Most drawn edges affect the visualization, except for two red ones that even if thicker they are passive ones.

!!A tutorial

!!!Nodes, edges and layouts

The most basic parts of a Mondrian view are:
# Nodes
# Edges
# Layout

Let's see how we create these. First the nodes.

[[[example=GtMondrianBasicExamples>>#twoNodes|expanded=true|show=gtLiveIn:]]]

Given those nodes, we can build edges.

[[[example=GtMondrianBasicExamples>>#oneEdgeBetweenTwoNodes|expanded=true|show=gtLiveIn:]]]

And finally, we lay them out.

[[[example=GtMondrianBasicExamples>>#layoutOnOneEdgeBetweenTwoNodes|expanded=true|show=gtLiveIn:]]]

!!!Shapes

The look and feel of nodes and edges is specified by Shapes, which can be included in the construction of nodes and edges.

A shape can be defined by a block that takes the node's model object as its argument and returns an instance of a Bloc element. In the example below, we see nine nodes drawn as circles with black borders, whose sizes depend on the number which each node represents.

[[[example=GtMondrianBasicExamples>>#nodesWithEllipses|expanded=true|show=gtLiveIn:]]]

We can define the shape of edges in a similar way. In the example below, the nodes are connected by blue edges whose width varies depending on the node it tries to connect.

[[[example=GtMondrianBasicExamples>>#edgesWithThickerLines|expanded=true|show=gtLiveIn:]]]


!!!Nesting

Mondrian graphs can also be nested. In other words, a node can have a subgraph.

[[[example=GtMondrianBasicExamples>>#nestedNodes|expanded=true|show=gtLiveIn:]]]

Nested nodes behave like leaf nodes in that they can be connected through edges and laid out accordingly.

[[[example=GtMondrianBasicExamples>>#nestedWithEdges|expanded=true|show=gtLiveIn:]]]

!!Domain-specific examples

Mondrian is useful for creating custom views that are specific to a given domain.

!!!Package dependencies

[[[example=GtMondrianDomainExamples>>#packageDependencies|expanded=true|show=gtLiveIn:]]]

!!!Examples dependencies

[[[example=GtMondrianDomainExamples>>#exampleDependencies|expanded=true|show=gtLiveIn:]]]
